<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
</head>
<body>
  {% if not creds %}
    <a href="{% url 'driveapp:login' %}">
      <button>Connect Google Drive</button>
    </a>
  {% else %}
    <p>‚úÖ Drive connected.</p>
    <button id="picker">Pick Files/Folders</button>
    <div id="action-choices" style="display:none; margin-top:1em;">
      <button id="download-btn">Download</button>
      <input id="search-query" type="text" placeholder="Search files by name..." style="margin-top:1em; width:300px;" />
      <button id="run-search">üîç Search</button>
    </div>

    <pre id="picker-result"></pre>
  {% endif %}

  <script>
    const ALLOWED_MIME_TYPES = JSON.parse('{{ allowed_mimes|escapejs }}');
    const oauthToken  = "{{ creds.token|default:'' }}";
    const apiKey      = "{{ api_key }}";
    const csrftoken   = "{{ csrf_token }}";
    
    if (oauthToken) {
      document.getElementById('picker')
        ?.addEventListener('click', () => gapi.load('picker', { callback: buildPicker }));

      let pickedDocs = null;

      function buildPicker() {
        const view = new google.picker.DocsView(google.picker.ViewId.DOCS)
          .setIncludeFolders(true)
          .setSelectFolderEnabled(true)
          .setMimeTypes([...ALLOWED_MIME_TYPES, 'application/vnd.google-apps.folder'].join(','));

        new google.picker.PickerBuilder()
          .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
          .setDeveloperKey(apiKey)
          .addView(view)
          .setOAuthToken(oauthToken)
          .setCallback(pickerCallback)
          .build()
          .setVisible(true);
      }

      function showActionChoices(show) {
        document.getElementById('action-choices').style.display = show ? '' : 'none';
      }

      async function pickerCallback(data) {
        if (data.action !== google.picker.Action.PICKED) return;
        pickedDocs = data.docs;
        showActionChoices(true);
        writeStatus('üîñ Items selected. Choose an action.');
      }

      document.getElementById('download-btn').addEventListener('click', async function() {
        if (!pickedDocs) return;
        showActionChoices(false);
        writeStatus('üîñ Downloading...');
        await fetch("{% url 'driveapp:metadata' %}", {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
          body: JSON.stringify({ docs: pickedDocs })
        }).catch(console.error);

        const res = await fetch("{% url 'driveapp:fetch' %}", {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
          body: JSON.stringify({ docs: pickedDocs })
        });

        if (!res.ok) {
          const txt = await res.text();
          writeStatus(`‚ùå Download failed: ${txt}`);
          return;
        }

        const { downloaded } = await res.json();
        writeStatus(`‚úÖ Downloaded ${downloaded.length} file(s):\n` +
                    JSON.stringify(downloaded, null, 2));
        pickedDocs = null;
      });

      document.getElementById('run-search')?.addEventListener('click', async () => {
        // 1) Validation
        if (!pickedDocs || pickedDocs.length === 0) {
          writeStatus('‚ùå No files or folders selected.');
          return;
        }
        const input = document.getElementById('search-query').value.trim();
        if (!input) {
          writeStatus('‚ùå Empty search query.');
          return;
        }

        // 2) Prepare search terms
        const words = input.split(/\s+/).map(w => w.toLowerCase());
        // Format for orderless word search: name contains 'foo' and name contains 'bar'
        const terms = words.map(w => `name contains '${w.replace(/'/g, "\\'")}'`);
        const searchQuery = terms.join(' and ');

        writeStatus(`üîç Running search for: ${searchQuery}`);

        // 3) Filter selected docs *client-side*
        const selectedMatches = pickedDocs.filter(doc =>
          words.every(w => doc.name.toLowerCase().includes(w))
        );

        // 4) Search entire Drive (allDrives)
        let driveResults = [];
        try {
          const res = await fetch("{% url 'driveapp:search' %}", {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({ query: searchQuery, corpora: 'allDrives' })
          });
          if (!res.ok) throw new Error(await res.text());
          const data = await res.json();
          driveResults = data.results || [];
        } catch (err) {
          writeStatus(`‚ùå Drive search failed: ${err.message}`);
          return;
        }

        // 5) Render exactly two result groups
        const selBlock = `üóÇ Selected (${selectedMatches.length}):\n` +
          (selectedMatches.length
            ? selectedMatches.map(d => ` - ${d.name} (${d.id})`).join('\n')
            : '  (no matches in selection)');
        const allBlock = `üåê All Drives (${driveResults.length}):\n` +
          (driveResults.length
            ? driveResults.map(d => ` - ${d.name} (${d.id})`).join('\n')
            : '  (no matches in Drive)');

        writeStatus(`üîç Results for: "${input}"\n\n${selBlock}\n\n${allBlock}`);
      });

      function writeStatus(msg) {
        document.getElementById('picker-result').textContent = msg;
      }

      
      function writeStatus(msg) {
        document.getElementById('picker-result').textContent = msg;
      }
    }
    </script>
    
</body>
</html>